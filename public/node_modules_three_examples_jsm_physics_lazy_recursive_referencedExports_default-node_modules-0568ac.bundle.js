/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkshaderplayground"] = self["webpackChunkshaderplayground"] || []).push([["node_modules_three_examples_jsm_physics_lazy_recursive_referencedExports_default-node_modules-0568ac"],{

/***/ "./node_modules/three/examples/jsm/physics lazy recursive ^.*$ referencedExports: default":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/three/examples/jsm/physics/ lazy ^.*$ referencedExports: default strict namespace object ***!
  \***************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var map = {\n\t\"./AmmoPhysics.js\": \"./node_modules/three/examples/jsm/physics/AmmoPhysics.js\",\n\t\"./JoltPhysics.js\": \"./node_modules/three/examples/jsm/physics/JoltPhysics.js\",\n\t\"./RapierPhysics.js\": \"./node_modules/three/examples/jsm/physics/RapierPhysics.js\"\n};\n\nfunction webpackAsyncContext(req) {\n\treturn Promise.resolve().then(() => {\n\t\tif(!__webpack_require__.o(map, req)) {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t}\n\n\t\tvar id = map[req];\n\t\treturn __webpack_require__(id);\n\t});\n}\nwebpackAsyncContext.keys = () => (Object.keys(map));\nwebpackAsyncContext.id = \"./node_modules/three/examples/jsm/physics lazy recursive ^.*$ referencedExports: default\";\nmodule.exports = webpackAsyncContext;\n\n//# sourceURL=webpack://shaderplayground/./node_modules/three/examples/jsm/physics/_lazy_^.*$_referencedExports:_default_strict_namespace_object?");

/***/ }),

/***/ "./node_modules/three/examples/jsm/physics/JoltPhysics.js":
/*!****************************************************************!*\
  !*** ./node_modules/three/examples/jsm/physics/JoltPhysics.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JoltPhysics: () => (/* binding */ JoltPhysics)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.core.js\");\n\n\nconst JOLT_PATH = 'https://cdn.jsdelivr.net/npm/jolt-physics@0.23.0/dist/jolt-physics.wasm-compat.js';\n\nconst frameRate = 60;\n\nlet Jolt = null;\n\nfunction getShape( geometry ) {\n\n\tconst parameters = geometry.parameters;\n\n\t// TODO change type to is*\n\n\tif ( geometry.type === 'BoxGeometry' ) {\n\n\t\tconst sx = parameters.width !== undefined ? parameters.width / 2 : 0.5;\n\t\tconst sy = parameters.height !== undefined ? parameters.height / 2 : 0.5;\n\t\tconst sz = parameters.depth !== undefined ? parameters.depth / 2 : 0.5;\n\n\t\treturn new Jolt.BoxShape( new Jolt.Vec3( sx, sy, sz ), 0.05 * Math.min( sx, sy, sz ), null );\n\n\t} else if ( geometry.type === 'SphereGeometry' || geometry.type === 'IcosahedronGeometry' ) {\n\n\t\tconst radius = parameters.radius !== undefined ? parameters.radius : 1;\n\n\t\treturn new Jolt.SphereShape( radius, null );\n\n\t}\n\n\treturn null;\n\n}\n\n// Object layers\nconst LAYER_NON_MOVING = 0;\nconst LAYER_MOVING = 1;\nconst NUM_OBJECT_LAYERS = 2;\n\nfunction setupCollisionFiltering( settings ) {\n\n\tlet objectFilter = new Jolt.ObjectLayerPairFilterTable( NUM_OBJECT_LAYERS );\n\tobjectFilter.EnableCollision( LAYER_NON_MOVING, LAYER_MOVING );\n\tobjectFilter.EnableCollision( LAYER_MOVING, LAYER_MOVING );\n\n\tconst BP_LAYER_NON_MOVING = new Jolt.BroadPhaseLayer( 0 );\n\tconst BP_LAYER_MOVING = new Jolt.BroadPhaseLayer( 1 );\n\tconst NUM_BROAD_PHASE_LAYERS = 2;\n\n\tlet bpInterface = new Jolt.BroadPhaseLayerInterfaceTable( NUM_OBJECT_LAYERS, NUM_BROAD_PHASE_LAYERS );\n\tbpInterface.MapObjectToBroadPhaseLayer( LAYER_NON_MOVING, BP_LAYER_NON_MOVING );\n\tbpInterface.MapObjectToBroadPhaseLayer( LAYER_MOVING, BP_LAYER_MOVING );\n\n\tsettings.mObjectLayerPairFilter = objectFilter;\n\tsettings.mBroadPhaseLayerInterface = bpInterface;\n\tsettings.mObjectVsBroadPhaseLayerFilter = new Jolt.ObjectVsBroadPhaseLayerFilterTable( settings.mBroadPhaseLayerInterface, NUM_BROAD_PHASE_LAYERS, settings.mObjectLayerPairFilter, NUM_OBJECT_LAYERS );\n\n};\n\nasync function JoltPhysics() {\n\n\tif ( Jolt === null ) {\n\n\t\tconst { default: initJolt } = await __webpack_require__(\"./node_modules/three/examples/jsm/physics lazy recursive ^.*$ referencedExports: default\")(`${JOLT_PATH}`);\n\t\tJolt = await initJolt();\n\n\t}\n\n\tconst settings = new Jolt.JoltSettings();\n\tsetupCollisionFiltering( settings );\n\n\tconst jolt = new Jolt.JoltInterface( settings );\n\tJolt.destroy( settings );\n\n\tconst physicsSystem = jolt.GetPhysicsSystem();\n\tconst bodyInterface = physicsSystem.GetBodyInterface();\n\n\tconst meshes = [];\n\tconst meshMap = new WeakMap();\n\n\tconst _position = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n\tconst _quaternion = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n\tconst _scale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3( 1, 1, 1 );\n\n\tconst _matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n\n\tfunction addScene( scene ) {\n\n\t\tscene.traverse( function ( child ) {\n\n\t\t\tif ( child.isMesh ) {\n\n\t\t\t\tconst physics = child.userData.physics;\n\n\t\t\t\tif ( physics ) {\n\n\t\t\t\t\taddMesh( child, physics.mass, physics.restitution );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\tfunction addMesh( mesh, mass = 0, restitution = 0 ) {\n\n\t\tconst shape = getShape( mesh.geometry );\n\n\t\tif ( shape === null ) return;\n\n\t\tconst body = mesh.isInstancedMesh\n\t\t\t\t\t\t\t? createInstancedBody( mesh, mass, restitution, shape )\n\t\t\t\t\t\t\t: createBody( mesh.position, mesh.quaternion, mass, restitution, shape );\n\n\t\tif ( mass > 0 ) {\n\n\t\t\tmeshes.push( mesh );\n\t\t\tmeshMap.set( mesh, body );\n\n\t\t}\n\n\t}\n\n\tfunction createInstancedBody( mesh, mass, restitution, shape ) {\n\n\t\tconst array = mesh.instanceMatrix.array;\n\n\t\tconst bodies = [];\n\n\t\tfor ( let i = 0; i < mesh.count; i ++ ) {\n\n\t\t\tconst position = _position.fromArray( array, i * 16 + 12 );\n\t\t\tconst quaternion = _quaternion.setFromRotationMatrix( _matrix.fromArray( array, i * 16 ) ); // TODO Copilot did this\n\t\t\tbodies.push( createBody( position, quaternion, mass, restitution, shape ) );\n\n\t\t}\n\n\t\treturn bodies;\n\n\t}\n\n\tfunction createBody( position, rotation, mass, restitution, shape ) {\n\n\t\tconst pos = new Jolt.Vec3( position.x, position.y, position.z );\n\t\tconst rot = new Jolt.Quat( rotation.x, rotation.y, rotation.z, rotation.w );\n\n\t\tconst motion = mass > 0 ? Jolt.EMotionType_Dynamic : Jolt.EMotionType_Static;\n\t\tconst layer = mass > 0 ? LAYER_MOVING : LAYER_NON_MOVING;\n\n\t\tconst creationSettings = new Jolt.BodyCreationSettings( shape, pos, rot, motion, layer );\n\t\tcreationSettings.mRestitution = restitution;\n\n\t\tconst body = bodyInterface.CreateBody( creationSettings );\n\n\t\tbodyInterface.AddBody( body.GetID(), Jolt.EActivation_Activate );\n\n\t\tJolt.destroy( creationSettings );\n\n\t\treturn body;\n\n\t}\n\n\tfunction setMeshPosition( mesh, position, index = 0 ) {\n\n\t\tif ( mesh.isInstancedMesh ) {\n\n\t\t\tconst bodies = meshMap.get( mesh );\n\n\t\t\tconst body = bodies[ index ];\n\n\t\t\tbodyInterface.RemoveBody( body.GetID() );\n\t\t\tbodyInterface.DestroyBody( body.GetID() );\n\n\t\t\tconst physics = mesh.userData.physics;\n\n\t\t\tlet shape = body.GetShape();\n\t\t\tlet body2 = createBody( position, { x: 0, y: 0, z: 0, w: 1 }, physics.mass, physics.restitution, shape );\n\n\t\t\tbodies[ index ] = body2;\n\n\t\t} else {\n\n\t\t\t// TODO: Implement this\n\n\t\t}\n\n\t}\n\n\tfunction setMeshVelocity( mesh, velocity, index = 0 ) {\n\n\t\t/*\n\t\tlet body = meshMap.get( mesh );\n\n\t\tif ( mesh.isInstancedMesh ) {\n\n\t\t\tbody = body[ index ];\n\n\t\t}\n\n\t\tbody.setLinvel( velocity );\n\t\t*/\n\n\t}\n\n\t//\n\n\tconst clock = new three__WEBPACK_IMPORTED_MODULE_0__.Clock();\n\n\tfunction step() {\n\n\t\tlet deltaTime = clock.getDelta();\n\n\t\t// Don't go below 30 Hz to prevent spiral of death\n\t\tdeltaTime = Math.min( deltaTime, 1.0 / 30.0 );\n\n\t\t// When running below 55 Hz, do 2 steps instead of 1\n\t\tconst numSteps = deltaTime > 1.0 / 55.0 ? 2 : 1;\n\n\t\t// Step the physics world\n\t\tjolt.Step( deltaTime, numSteps );\n\n\t\t//\n\n\t\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\n\n\t\t\tconst mesh = meshes[ i ];\n\n\t\t\tif ( mesh.isInstancedMesh ) {\n\n\t\t\t\tconst array = mesh.instanceMatrix.array;\n\t\t\t\tconst bodies = meshMap.get( mesh );\n\n\t\t\t\tfor ( let j = 0; j < bodies.length; j ++ ) {\n\n\t\t\t\t\tconst body = bodies[ j ];\n\n\t\t\t\t\tconst position = body.GetPosition();\n\t\t\t\t\tconst quaternion = body.GetRotation();\n\n\t\t\t\t\t_position.set( position.GetX(), position.GetY(), position.GetZ() );\n\t\t\t\t\t_quaternion.set( quaternion.GetX(), quaternion.GetY(), quaternion.GetZ(), quaternion.GetW() );\n\n\t\t\t\t\t_matrix.compose( _position, _quaternion, _scale ).toArray( array, j * 16 );\n\n\t\t\t\t}\n\n\t\t\t\tmesh.instanceMatrix.needsUpdate = true;\n\t\t\t\tmesh.computeBoundingSphere();\n\n\t\t\t} else {\n\n\t\t\t\tconst body = meshMap.get( mesh );\n\n\t\t\t\tconst position = body.GetPosition();\n\t\t\t\tconst rotation = body.GetRotation();\n\n\t\t\t\tmesh.position.set( position.GetX(), position.GetY(), position.GetZ() );\n\t\t\t\tmesh.quaternion.set( rotation.GetX(), rotation.GetY(), rotation.GetZ(), rotation.GetW() );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// animate\n\n\tsetInterval( step, 1000 / frameRate );\n\n\treturn {\n\t\taddScene: addScene,\n\t\taddMesh: addMesh,\n\t\tsetMeshPosition: setMeshPosition,\n\t\tsetMeshVelocity: setMeshVelocity\n\t};\n\n}\n\n\n\n\n//# sourceURL=webpack://shaderplayground/./node_modules/three/examples/jsm/physics/JoltPhysics.js?");

/***/ })

}]);